use crate::fiat_shamir_hash::MiMC5FiatShamirHasher;
use arith::{BN254Fr, FiatShamirFieldHasher, FieldSerde};
use halo2curves::bn256::Fr;
use sha2::{Digest, Sha256};

const EXAMPLE_IN: [u8; 32] = [
    40, 75, 185, 12, 169, 4, 108, 43, 211, 74, 219, 14, 2, 133, 97, 27, 200, 245, 110, 1, 253, 219,
    2, 24, 175, 47, 213, 9, 147, 218, 9, 24,
];
const EXAMPLE_OUT: [u8; 32] = [
    176, 91, 203, 102, 207, 182, 237, 150, 102, 95, 91, 217, 57, 237, 83, 244, 151, 151, 81, 14,
    152, 21, 4, 26, 66, 178, 223, 244, 32, 37, 40, 171,
];

#[test]
fn check_sha256_aligned() {
    let out = Sha256::digest(EXAMPLE_IN);
    println!("{:?}", out);
    assert_eq!(out, EXAMPLE_OUT.into());
}

const MIMC5_BN254_IN: u32 = 123;

// The result is generated by the currect version (10/20/2024) of mimc5 itself.
// The point is to pin down a hash output so later we can refer to it.
// There is a similar test in recursion located at recursion/modules/transcript/hash_test.go
const MIMC5_BN254_ONT: [u8; 32] = [
    23, 0, 30, 22, 99, 236, 217, 86, 113, 255, 221, 106, 184, 226, 45, 109, 67, 123, 85, 88, 103,
    54, 177, 150, 88, 18, 208, 172, 76, 143, 30, 5,
];

#[test]
fn check_mimc5_aligned() {
    let mimc = MiMC5FiatShamirHasher::<Fr>::new();
    let input = BN254Fr::from(MIMC5_BN254_IN);
    let output = mimc.hash(&[input]);

    assert_eq!(output.len(), 1);
    assert_eq!(
        output[0],
        BN254Fr::deserialize_from(&MIMC5_BN254_ONT[..]).unwrap()
    );
}
