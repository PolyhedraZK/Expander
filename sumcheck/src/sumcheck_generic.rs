use std::ops::Mul;

use arith::Field;
use gkr_engine::Transcript;
use polynomials::{MultiLinearPoly, VPAuxInfo, VirtualPolynomial};
use serdes::ExpSerde;

mod prover;
pub use prover::*;

mod verifier;
pub use verifier::*;

#[cfg(test)]
mod tests;

// /// An IOP proof is a collections of
// /// - messages from prover to verifier at each round through the interactive protocol.
// /// - a point that is generated by the transcript for evaluation
// #[derive(Clone, Debug, Default, PartialEq, Eq)]
// pub struct IOPProof<F: Field> {
//     // pub point: Vec<F>,
//     pub proofs: Vec<IOPProverMessage<F>>,
// }

/// An IOP proof is a collections of messages from prover to verifier at each
/// round through the interactive protocol.
#[derive(Clone, Debug, Default, PartialEq)]
pub struct IOPProof<F: Field> {
    pub proofs: Vec<IOPProverMessage<F>>,
}

/// A message from the prover to the verifier at a given round
/// is a list of evaluations.
#[derive(Clone, Debug, Default, PartialEq, Eq, ExpSerde)]
pub struct IOPProverMessage<F: Field> {
    pub(crate) evaluations: Vec<F>,
}

/// Prover State of a PolyIOP.
pub struct IOPProverState<F: Field> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<F>,
    /// number of variables in the polynomial
    pub(crate) init_num_vars: usize,
    /// the current round number
    pub(crate) round: usize,
    /// list of MLE poly
    // todo: change this to reference
    // pub mle_list: Vec<MultiLinearPoly<F>>,
    pub mle: MultiLinearPoly<F>,
    // /// pointer to the virtual polynomial
    // pub(crate) poly: VirtualPolynomial<F>,
    // /// points with precomputed barycentric weights for extrapolating smaller
    // /// degree uni-polys to `max_degree + 1` evaluations.
    // pub(crate) extrapolation_aux: Vec<(Vec<F>, Vec<F>)>,
}

/// Prover State of a PolyIOP
pub struct IOPVerifierState<F: Field> {
    pub(crate) round: usize,
    pub(crate) num_vars: usize,
    // pub(crate) max_degree: usize,
    pub(crate) finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub(crate) polynomials_received: Vec<Vec<F>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub(crate) challenges: Vec<F>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: Field> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

// pub struct Sumcheck<F: Field> {
//     phantom: std::marker::PhantomData<F>,
// }

// impl<F: Field> Sumcheck<F> {
//     /// Extract sum from the proof
//     pub fn extract_sum(proof: &IOPProof<F>) -> F {
//         proof.proofs[0].evaluations[0] + proof.proofs[0].evaluations[1]
//     }

//     /// Generate proof of the sum of polynomial over {0,1}^`num_vars`
//     ///
//     /// The polynomial is represented in the form of a VirtualPolynomial.
//     pub fn prove(
//         poly_list: &[MultiLinearPoly<F>],
//         // poly: &VirtualPolynomial<F>,
//         transcript: &mut impl Transcript) -> IOPProof<F> {
//         // transcript.append_serializable_data(&poly.aux_info);

//         let mut prover_state = IOPProverState::prover_init(poly);
//         let mut challenge = None;
//         let mut prover_msgs = Vec::with_capacity(poly.aux_info.num_variables);
//         for _ in 0..poly.aux_info.num_variables {
//             let prover_msg =
//                 IOPProverState::prove_round_and_update_state(&mut prover_state, &challenge);
//             transcript.append_serializable_data(&prover_msg);
//             prover_msgs.push(prover_msg);
//             challenge = Some(transcript.generate_field_element::<F>());
//         }

//         println!("prover challenges: {:?}", prover_state.challenges);
//         IOPProof {
//             proofs: prover_msgs,
//         }
//     }

//     /// Verify the claimed sum using the proof
//     pub fn verify(
//         claimed_sum: F,
//         proof: &IOPProof<F>,
//         aux_info: &VPAuxInfo<F>,
//         transcript: &mut impl Transcript,
//     ) -> SumCheckSubClaim<F> {
//         transcript.append_serializable_data(aux_info);
//         let mut verifier_state = IOPVerifierState::verifier_init(aux_info);
//         for i in 0..aux_info.num_variables {
//             let prover_msg = proof.proofs.get(i).expect("proof is incomplete");
//             transcript.append_serializable_data(prover_msg);
//             IOPVerifierState::verify_round_and_update_state(
//                 &mut verifier_state,
//                 prover_msg,
//                 transcript,
//             );
//         }

//         println!("verifier challenges: {:?}", verifier_state.challenges);
//         IOPVerifierState::check_and_generate_subclaim(&verifier_state, &claimed_sum)
//     }
// }
