//! This module implements the SumCheck protocol for verifying the sum of
//! evaluations of a set of multi-linear polynomial over the hypercube {0,1}^n.
//! This is hardcoded for sum of product of MLEs for simplicity and efficiency.
// Credit: code adopted from https://github.com/EspressoSystems/hyperplonk/ with modification

use arith::Field;
use gkr_engine::Transcript;
use polynomials::SumOfProductsPoly;
use serdes::ExpSerde;

mod prover;
mod verifier;

#[cfg(test)]
mod tests;

/// An IOP proof is a collections of
/// - messages from prover to verifier at each round through the interactive protocol.
/// - a point that is generated by the transcript for evaluation
#[derive(Clone, Debug, Default, PartialEq, Eq, ExpSerde)]
pub struct IOPProof<F: Field> {
    pub proofs: Vec<IOPProverMessage<F>>,
    pub point: Vec<F>,
}

impl<F: Field> IOPProof<F> {
    /// The endianness of SumCheck is reversed c.f. the rest of expander.
    pub fn export_point_to_expander(&self) -> Vec<F> {
        let mut point = self.point.clone();
        point.reverse();
        point
    }
}

/// A message from the prover to the verifier at a given round
/// is a list of evaluations.
#[derive(Clone, Debug, Default, PartialEq, Eq, ExpSerde)]
pub struct IOPProverMessage<F: Field> {
    pub(crate) evaluations: Vec<F>,
}

/// Prover State of a PolyIOP.
pub struct IOPProverState<F: Field> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<F>,
    /// number of variables in the polynomial
    pub(crate) init_num_vars: usize,
    /// the current round number
    pub(crate) round: usize,
    /// list of MLE poly
    // todo: change this to reference
    pub mle_list: SumOfProductsPoly<F>,
}

/// Prover State of a PolyIOP
pub struct IOPVerifierState<F: Field> {
    pub(crate) round: usize,
    pub(crate) num_vars: usize,
    // pub(crate) max_degree: usize,
    pub(crate) finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub(crate) polynomials_received: Vec<Vec<F>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub(crate) challenges: Vec<F>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: Field> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

pub struct SumCheck<F: Field> {
    phantom: std::marker::PhantomData<F>,
}

impl<F: Field> SumCheck<F> {
    /// Extract sum from the proof
    pub fn extract_sum(proof: &IOPProof<F>) -> F {
        proof.proofs[0].evaluations[0] + proof.proofs[0].evaluations[1]
    }

    /// Generate proof of the sum of polynomial over {0,1}^`num_vars`
    ///
    /// The polynomial is represented in the form of a VirtualPolynomial.
    pub fn prove(
        poly_list: &SumOfProductsPoly<F>,
        transcript: &mut impl Transcript,
    ) -> IOPProof<F> {
        let num_vars = poly_list.num_vars();

        let mut prover_state = IOPProverState::prover_init(poly_list);
        let mut challenge = None;
        let mut prover_msgs = Vec::with_capacity(num_vars);
        for _ in 0..num_vars {
            let prover_msg =
                IOPProverState::prove_round_and_update_state(&mut prover_state, &challenge);
            transcript.append_serializable_data(&prover_msg);
            prover_msgs.push(prover_msg);
            challenge = Some(transcript.generate_field_element::<F>());
        }
        // pushing the last challenge point to the state
        if let Some(p) = challenge {
            prover_state.challenges.push(p)
        };

        IOPProof {
            point: prover_state.challenges,
            proofs: prover_msgs,
        }
    }

    /// Verify the claimed sum using the proof
    pub fn verify(
        claimed_sum: F,
        proof: &IOPProof<F>,
        num_vars: usize,
        transcript: &mut impl Transcript,
    ) -> (bool, SumCheckSubClaim<F>) {
        let mut verifier_state = IOPVerifierState::verifier_init(num_vars);
        for i in 0..num_vars {
            let prover_msg = proof.proofs.get(i).expect("proof is incomplete");
            transcript.append_serializable_data(prover_msg);
            IOPVerifierState::verify_round_and_update_state(
                &mut verifier_state,
                prover_msg,
                transcript,
            );
        }

        IOPVerifierState::check_and_generate_subclaim(&verifier_state, &claimed_sum)
    }
}
