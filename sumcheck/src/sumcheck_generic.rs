//! Generic sumcheck protocol implementation.
//! Modified from Hyperplonk code base, with modifications.
//! https://github.com/EspressoSystems/hyperplonk/blob/main/subroutines/src/poly_iop/sum_check/
// TODO: for now this only supports the case where challenge field and base field are the same.

use std::sync::Arc;

use arith::Field;
use gkr_engine::Transcript;
use polynomials::{MultiLinearPoly, VPAuxInfo, VirtualPolynomial};
use serdes::ExpSerde;

/// Prover State
pub struct ProverState<F: Field> {
    pub challenges: Vec<F>,
    pub round: usize,
    pub virtual_poly: VirtualPolynomial<F>,
}

/// Verifier State
pub struct VerifierState<F: Field> {
    pub round: usize,
    pub num_vars: usize,
    pub max_degree: usize,
    pub finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub polynomials_received: Vec<Vec<F>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub challenges: Vec<F>,
}

/// Proof
pub struct SumcheckProof<F: Field> {
    /// list of messages send from prover to verifier at each round
    pub iop_message: Vec<IOPProverMessage<F>>,
    /// challenge received from verifier at each round
    pub challenges: Vec<F>,
}

/// message sent from prover to verifier at each round
#[derive(Clone, Debug, Default, PartialEq, Eq, ExpSerde)]
pub struct IOPProverMessage<F: Field> {
    /// evaluations of the polynomial at the current round
    pub evaluations: Vec<F>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: Field> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

pub struct GenericSumcheck<F: Field> {
    phantom: std::marker::PhantomData<F>,
}

impl<F: Field> GenericSumcheck<F> {
    #[inline]
    pub fn extract_sum(proof: &SumcheckProof<F>) -> F {
        proof.iop_message[0].evaluations[0] + proof.iop_message[0].evaluations[1]
    }

    #[inline]
    pub fn prove(
        poly: &VirtualPolynomial<F>,
        transcript: &mut impl Transcript,
    ) -> SumcheckProof<F> {
        transcript.append_serializable_data(&poly.aux_info);

        println!("aux info: {:?}", poly.aux_info);

        let mut prover_state = ProverState::prover_init(poly);
        let mut challenge = None;
        let mut prover_msgs = Vec::with_capacity(poly.aux_info.num_variables);
        for _ in 0..poly.aux_info.num_variables {
            let prover_msg =
                ProverState::prove_round_and_update_state(&mut prover_state, &challenge);
            transcript.append_serializable_data(&prover_msg);
            prover_msgs.push(prover_msg);
            challenge = Some(transcript.generate_field_element::<F>());
        }
        // pushing the last challenge point to the state
        if let Some(p) = challenge {
            prover_state.challenges.push(p)
        };
        println!("prover challenges: {:?}", prover_state.challenges);
        SumcheckProof {
            challenges: prover_state.challenges,
            iop_message: prover_msgs,
        }
    }

    #[inline]
    pub fn verify(
        claimed_sum: F,
        proof: &SumcheckProof<F>,
        aux_info: &VPAuxInfo<F>,
        transcript: &mut impl Transcript,
    ) -> SumCheckSubClaim<F> {
        transcript.append_serializable_data(aux_info);
        let mut verifier_state = VerifierState::verifier_init(aux_info);


        println!("aux info: {:?}", aux_info);
        for i in 0..aux_info.num_variables {
            let prover_msg = proof.iop_message.get(i).expect("proof is incomplete");
            transcript.append_serializable_data(prover_msg);
            VerifierState::verify_round_and_update_state(
                &mut verifier_state,
                prover_msg,
                transcript,
            );
        }

        println!("verifier challenges: {:?}", verifier_state.challenges);
        VerifierState::check_and_generate_subclaim(&verifier_state, &claimed_sum)
    }
}

impl<F: Field> ProverState<F> {
    /// Initialize the prover state to argue for the sum of the input polynomial
    /// over {0,1}^`num_vars`.
    #[inline]
    pub fn prover_init(polynomials: &VirtualPolynomial<F>) -> Self {
        if polynomials.aux_info.num_variables == 0 {
            panic!("Attempt to prove a constant.");
        }

        Self {
            challenges: Vec::with_capacity(polynomials.aux_info.num_variables),
            round: 0,
            virtual_poly: polynomials.clone(),
        }
    }

    /// Receive message from verifier, generate prover message, and proceed to
    /// next round.
    ///
    /// Main algorithm used is from section 3.2 of [XZZPS19](https://eprint.iacr.org/2019/317.pdf#subsection.3.2).
    pub fn prove_round_and_update_state(&mut self, challenge: &Option<F>) -> IOPProverMessage<F> {
        if self.round >= self.virtual_poly.aux_info.num_variables {
            panic!("Prover has already finished all rounds");
        }

        // Step 1:
        // fix argument and evaluate f(x) over x_m = r; where r is the challenge
        // for the current round, and m is the round number, indexed from 1
        //
        // i.e.:
        // at round m <= n, for each mle g(x_1, ... x_n) within the flattened_mle
        // which has already been evaluated to
        //
        //    g(r_1, ..., r_{m-1}, x_m ... x_n)
        //
        // eval g over r_m, and mutate g to g(r_1, ... r_m,, x_{m+1}... x_n)

        let mut flattened_ml_extensions: Vec<MultiLinearPoly<F>> = self
            .virtual_poly
            .flattened_ml_extensions
            .iter()
            .map(|x| x.as_ref().clone())
            .collect();

        if let Some(chal) = challenge {
            if self.round == 0 {
                panic!("first round should be prover first.");
            }
            self.challenges.push(*chal);

            let r = self.challenges[self.round - 1];

            flattened_ml_extensions
                .iter_mut()
                .for_each(|mle| mle.fix_variables(&[r]));
        } else if self.round > 0 {
            panic!("verifier message is empty");
        }

        self.round += 1;

        let products_list = self.virtual_poly.products.clone();
        let mut products_sum = vec![F::zero(); self.virtual_poly.aux_info.max_degree + 1];

        // Step 2: generate sum for the partial evaluated polynomial:
        // f(r_1, ... r_m,, x_{m+1}... x_n)

        products_sum.iter_mut().enumerate().for_each(|(t, e)| {
            let t = F::from(t as u32);

            for b in 0..1 << (self.virtual_poly.aux_info.num_variables - self.round) {
                // evaluate P_round(t)
                for (coefficient, products) in products_list.iter() {
                    let num_mles = products.len();
                    let mut product = *coefficient;
                    for &f in products.iter().take(num_mles) {
                        let table = &flattened_ml_extensions[f]; // f's range is checked in init
                        product *= table[b << 1] + (table[(b << 1) + 1] - table[b << 1]) * t;
                    }
                    *e += product;
                }
            }
        });

        // update prover's state to the partial evaluated polynomial
        self.virtual_poly.flattened_ml_extensions = flattened_ml_extensions
            .iter()
            .map(|x| Arc::new(x.clone()))
            .collect();

        // update prover's state to the partial evaluated polynomial
        self.virtual_poly.flattened_ml_extensions = flattened_ml_extensions
            .iter()
            .map(|x| Arc::new(x.clone()))
            .collect();

        IOPProverMessage {
            evaluations: products_sum,
        }
    }
}

impl<F: Field> VerifierState<F> {
    /// Initialize the verifier's state.
    #[inline]
    pub fn verifier_init(index_info: &VPAuxInfo<F>) -> Self {
        Self {
            round: 1,
            num_vars: index_info.num_variables,
            max_degree: index_info.max_degree,
            finished: false,
            polynomials_received: Vec::with_capacity(index_info.num_variables),
            challenges: Vec::with_capacity(index_info.num_variables),
        }
    }

    /// Run verifier for the current round, given a prover message.
    ///
    /// Note that `verify_round_and_update_state` only samples and stores
    /// challenges; and update the verifier's state accordingly. The actual
    /// verifications are deferred (in batch) to `check_and_generate_subclaim`
    /// at the last step.
    #[inline]
    pub fn verify_round_and_update_state(
        &mut self,
        prover_msg: &IOPProverMessage<F>,
        transcript: &mut impl Transcript,
    ) -> F {
        if self.finished {
            panic!("Incorrect verifier state: Verifier is already finished.")
        }

        // In an interactive protocol, the verifier should
        //
        // 1. check if the received 'P(0) + P(1) = expected`.
        // 2. set `expected` to P(r)`
        //
        // When we turn the protocol to a non-interactive one, it is sufficient to defer
        // such checks to `check_and_generate_subclaim` after the last round.

        let challenge = transcript.generate_field_element::<F>();
        self.challenges.push(challenge);
        self.polynomials_received
            .push(prover_msg.evaluations.to_vec());

        if self.round == self.num_vars {
            // accept and close
            self.finished = true;
        } else {
            // proceed to the next round
            self.round += 1;
        }

        challenge
    }

    /// This function verifies the deferred checks in the interactive version of
    /// the protocol; and generate the subclaim. Returns an error if the
    /// proof failed to verify.
    ///
    /// If the asserted sum is correct, then the multilinear polynomial
    /// evaluated at `subclaim.point` will be `subclaim.expected_evaluation`.
    /// Otherwise, it is highly unlikely that those two will be equal.
    /// Larger field size guarantees smaller soundness error.
    pub fn check_and_generate_subclaim(&self, asserted_sum: &F) -> SumCheckSubClaim<F> {
        if !self.finished {
            panic!("Incorrect verifier state: Verifier has not finished.");
        }

        if self.polynomials_received.len() != self.num_vars {
            panic!("insufficient rounds")
        }

        // the deferred check during the interactive phase:
        // 2. set `expected` to P(r)`
        let mut expected_vec = self
            .polynomials_received
            .clone()
            .into_iter()
            .zip(self.challenges.clone().into_iter())
            .map(|(evaluations, challenge)| {
                if evaluations.len() != self.max_degree + 1 {
                    panic!(
                        "incorrect number of evaluations: {} vs {}",
                        evaluations.len(),
                        self.max_degree + 1
                    )
                }
                interpolate_uni_poly::<F>(&evaluations, challenge)
            })
            .collect::<Vec<_>>();

        // insert the asserted_sum to the first position of the expected vector
        expected_vec.insert(0, *asserted_sum);

        for (i,(evaluations, &expected)) in self
            .polynomials_received
            .iter()
            .zip(expected_vec.iter())
            .take(self.num_vars).enumerate()
        {
            // the deferred check during the interactive phase:
            // 1. check if the received 'P(0) + P(1) = expected`.


             println!(
                    "{} layer: {} evaluations: {:?}\nsum: {:?}\nexpected: {:?}",
                    i,evaluations.len(), evaluations, evaluations[0] + evaluations[1], expected
                );
            if evaluations[0] + evaluations[1] != expected {
               
                panic!("Prover message is not consistent with the claim.")
            }
        }
        SumCheckSubClaim {
            point: self.challenges.clone(),
            // the last expected value (not checked within this function) will be included in the
            // subclaim
            expected_evaluation: expected_vec[self.num_vars],
        }
    }
}

/// Interpolate a uni-variate degree-`p_i.len()-1` polynomial and evaluate this
/// polynomial at `eval_at`:
///
///   \sum_{i=0}^len p_i * (\prod_{j!=i} (eval_at - j)/(i-j) )
///
/// This implementation is linear in number of inputs in terms of field
/// operations. It also has a quadratic term in primitive operations which is
/// negligible compared to field operations.
/// TODO: The quadratic term can be removed by precomputing the lagrange
/// coefficients.
pub(crate) fn interpolate_uni_poly<F: Field>(p_i: &[F], eval_at: F) -> F {
    let len = p_i.len();
    let mut evals = vec![];
    let mut prod = eval_at;
    evals.push(eval_at);

    // `prod = \prod_{j} (eval_at - j)`
    for e in 1..len {
        let tmp = eval_at - F::from(e as u32);
        evals.push(tmp);
        prod *= tmp;
    }
    let mut res = F::zero();
    // // we want to compute \prod (j!=i) (i-j) for a given i
    // //
    // // we start from the last step, which is
    // //  denom[len-1] = (len-1) * (len-2) *... * 2 * 1
    // // the step before that is
    // //  denom[len-2] = (len-2) * (len-3) * ... * 2 * 1 * -1
    // // and the step before that is
    // //  denom[len-3] = (len-3) * (len-4) * ... * 2 * 1 * -1 * -2
    // //
    // // i.e., for any i, the one before this will be derived from
    // //  denom[i-1] = denom[i] * (len-i) / i
    // //
    // // that is, we only need to store
    // // - the last denom for i = len-1, and
    // // - the ratio between current step and fhe last step, which is the product of (len-i) / i from
    // //   all previous steps and we store this product as a fraction number to reduce field
    // //   divisions.

    // // We know
    // //  - 2^61 < factorial(20) < 2^62
    // //  - 2^122 < factorial(33) < 2^123
    // // so we will be able to compute the ratio
    // //  - for len <= 20 with i64
    // //  - for len <= 33 with i128
    // //  - for len >  33 with BigInt
    // if p_i.len() <= 20 {
    //     let last_denominator = F::from_u256(u64_factorial(len - 1).into());
    //     let mut ratio_numerator = 1i64;
    //     let mut ratio_denominator = 1u64;

    //     for i in (0..len).rev() {
    //         let ratio_numerator_f = if ratio_numerator < 0 {
    //             -F::from_u256(((-ratio_numerator) as u64).into())
    //         } else {
    //             F::from_u256((ratio_numerator as u64).into())
    //         };

    //         res += p_i[i]
    //             * prod
    //             * F::from_u256(ratio_denominator.into())
    //             * (last_denominator * ratio_numerator_f * evals[i])
    //                 .inv()
    //                 .unwrap();

    //         // compute denom for the next step is current_denom * (len-i)/i
    //         if i != 0 {
    //             ratio_numerator *= -(len as i64 - i as i64);
    //             ratio_denominator *= i as u64;
    //         }
    //     }
    // } else if p_i.len() <= 33 {
    //     let last_denominator = F::from_u256(u128_factorial(len - 1).into());
    //     let mut ratio_numerator = 1i128;
    //     let mut ratio_denominator = 1u128;

    //     for i in (0..len).rev() {
    //         let ratio_numerator_f = if ratio_numerator < 0 {
    //             -F::from_u256(((-ratio_numerator) as u128).into())
    //         } else {
    //             F::from_u256((ratio_numerator as u128).into())
    //         };

    //         res += p_i[i]
    //             * prod
    //             * F::from_u256((ratio_denominator as u128).into())
    //             * (last_denominator * ratio_numerator_f * evals[i])
    //                 .inv()
    //                 .unwrap();

    //         // compute denom for the next step is current_denom * (len-i)/i
    //         if i != 0 {
    //             ratio_numerator *= -(len as i128 - i as i128);
    //             ratio_denominator *= i as u128;
    //         }
    //     }
    // } else {
        let mut denom_up = field_factorial::<F>(len - 1);
        let mut denom_down = F::one();

        for i in (0..len).rev() {
            res += p_i[i] * prod * denom_down * (denom_up * evals[i]).inv().unwrap();

            // compute denom for the next step is current_denom * (len-i)/i
            if i != 0 {
                denom_up *= -F::from((len - i) as u32);
                denom_down *= F::from(i as u32);
            }
        }
    // }
    res
}

/// compute the factorial(a) = 1 * 2 * ... * a
#[inline]
fn field_factorial<F: Field>(a: usize) -> F {
    let mut res = F::one();
    for i in 2..=a {
        res *= F::from(i as u32);
    }
    res
}

/// compute the factorial(a) = 1 * 2 * ... * a
#[inline]
fn u128_factorial(a: usize) -> u128 {
    let mut res = 1u128;
    for i in 2..=a {
        res *= i as u128;
    }
    res
}

/// compute the factorial(a) = 1 * 2 * ... * a
#[inline]
fn u64_factorial(a: usize) -> u64 {
    let mut res = 1u64;
    for i in 2..=a {
        res *= i as u64;
    }
    res
}
