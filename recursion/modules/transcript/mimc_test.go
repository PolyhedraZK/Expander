package transcript

import (
	"math/big"
	"testing"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/std/hash/mimc"
)

type Hash struct {
	Input  frontend.Variable
	Output frontend.Variable
}

func (h *Hash) Define(api frontend.API) error {
	mimc, err := mimc.NewMiMC(api)
	if err != nil {
		panic("Fail to create mimc")
	}
	mimc.Write(h.Input)
	out := mimc.Sum()
	api.Println("Out", out)
	api.AssertIsEqual(out, h.Output)
	return nil
}

func TestHash(t *testing.T) {
	evaluation := Hash{}
	r1cs, r1cs_err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &evaluation)
	if r1cs_err != nil {
		panic("Unable to generate r1cs")
	}
	println("Nb Constraints: ", r1cs.GetNbConstraints())
	println("Nb Internal Witnesss: ", r1cs.GetNbInternalVariables())
	println("Nb Private Witness: ", r1cs.GetNbSecretVariables())
	println("Nb Public Witness:", r1cs.GetNbPublicVariables())

	// The hash output is generated by the MIMCHasher in the Expander repo
	nb_bytes := 32
	expected_le_output_bytes := []uint8{
		23, 0, 30, 22, 99, 236, 217, 86,
		113, 255, 221, 106, 184, 226, 45, 109,
		67, 123, 85, 88, 103, 54, 177, 150,
		88, 18, 208, 172, 76, 143, 30, 5,
	}
	if nb_bytes != len(expected_le_output_bytes) {
		panic("Incorrect length of expected output")
	}

	expected_be_output_bytes := make([]uint8, nb_bytes)
	for i := 0; i < nb_bytes; i++ {
		expected_be_output_bytes[i] = expected_le_output_bytes[nb_bytes-1-i]
	}

	assignment := Hash{
		Input:  123,
		Output: *big.NewInt(0).SetBytes(expected_be_output_bytes),
	}

	witness, witness_err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	if witness_err != nil {
		panic("Unable to solve witness")
	}

	err := r1cs.IsSolved(witness)
	if err != nil {
		panic("R1CS not satisfied")
	}
}
