package circuit

import (
	"encoding/binary"
	"fmt"
	"math/big"
	"math/bits"
	"os"

	"github.com/consensys/gnark/frontend"
)

type InputBuf struct {
	data      []byte
	fieldEnum ECCFieldEnum
}

func NewInputBuf(fileName string, fieldEnum ECCFieldEnum) (buf *InputBuf, err error) {
	data, err := os.ReadFile(fileName)
	if err != nil {
		return
	}
	buf = &InputBuf{data: data, fieldEnum: fieldEnum}
	return
}

func (buf *InputBuf) Step(n_bytes uint) {
	buf.data = buf.data[n_bytes:]
}

func (buf *InputBuf) Len() uint {
	return uint(len(buf.data))
}

func (buf *InputBuf) ReadUint64() uint64 {
	x := binary.LittleEndian.Uint64(buf.data[:8])
	buf.Step(8)
	return x
}

func (buf *InputBuf) ReadUint() uint {
	return uint(buf.ReadUint64())
}

func (buf *InputBuf) ReadUint8() uint8 {
	x := buf.data[0]
	buf.Step(1)
	return x
}

func (buf *InputBuf) ReadField(field_size_in_bytes uint) *big.Int {

	// little endian to big endian
	for i := uint(0); i < field_size_in_bytes/2; i++ {
		buf.data[i], buf.data[field_size_in_bytes-i-1] =
			buf.data[field_size_in_bytes-i-1], buf.data[i]
	}

	x := big.NewInt(0).SetBytes(buf.data[:field_size_in_bytes])
	buf.Step(field_size_in_bytes)
	return x
}

func (buf *InputBuf) ReadGate(input_num uint) (gate Gate, err error) {
	fieldBytes, err := buf.fieldEnum.FieldBytes()
	if err != nil {
		return
	}

	var i_ids []uint
	for i := uint(0); i < input_num; i++ {
		i_ids = append(i_ids, buf.ReadUint())
	}
	o_id := buf.ReadUint()

	var coef Coef
	coef_type_u8 := buf.ReadUint8()
	switch coef_type_u8 {
	case 1:
		coef.CoefType = Constant
		coef.Value = *buf.ReadField(fieldBytes)
		coef.RandomValue = 0 // This will not be used, but gnark will complain if this value is nil
	case 2:
		coef.CoefType = Random
		coef.RandomValue = 1 // Give some default value for random, the actuall value should be generated by transcript
	case 3:
		coef.CoefType = PublicInput
		coef.RandomValue = 0 // This will not be used, but gnark will complain if this value is nil
		coef.InputIdx = buf.ReadUint()
		if input_num != 0 {
			err = fmt.Errorf("Public input can only appear in the form of cst gate")
		}
	default:
		err = fmt.Errorf("Unrecognized coef type")
	}

	if err != nil {
		return
	}

	gate = Gate{
		IIds: i_ids,
		OId:  o_id,
		Coef: coef,
	}
	return
}

func (buf *InputBuf) ReadAllocation() Allocation {
	return Allocation{
		IOffset: buf.ReadUint(),
		OOffset: buf.ReadUint(),
	}
}

func (buf *InputBuf) ReadChildSegInfo() ChildSegInfo {
	id := buf.ReadUint()

	n_allocations := buf.ReadUint()
	var allocation []Allocation
	for i := uint(0); i < n_allocations; i++ {
		allocation = append(allocation, buf.ReadAllocation())
	}

	return ChildSegInfo{
		Id:         id,
		Allocation: allocation,
	}
}

func (buf *InputBuf) ReadSegment() (segment Segment, err error) {
	i_len := buf.ReadUint()
	o_len := buf.ReadUint()

	if bits.OnesCount(i_len) != 1 || bits.OnesCount(o_len) != 1 {
		err = fmt.Errorf("Incorrect input or output length")
		return
	}

	n_child_seg := buf.ReadUint()
	var child_segs []ChildSegInfo
	for i := uint(0); i < n_child_seg; i++ {
		child_segs = append(child_segs, buf.ReadChildSegInfo())
	}

	n_muls := buf.ReadUint()
	var tempGate Gate
	var muls []Gate
	for i := uint(0); i < n_muls; i++ {
		tempGate, err = buf.ReadGate(2)
		muls = append(muls, tempGate)
	}

	n_adds := buf.ReadUint()
	var adds []Gate
	for i := uint(0); i < n_adds; i++ {
		tempGate, err = buf.ReadGate(1)
		adds = append(adds, tempGate)
	}

	n_csts := buf.ReadUint()
	var csts []Gate
	for i := uint(0); i < n_csts; i++ {
		tempGate, err = buf.ReadGate(0)
		csts = append(csts, tempGate)
	}

	if err != nil {
		return
	}

	n_customs := buf.ReadUint()
	if n_customs != 0 {
		err = fmt.Errorf("Custom gate not supported yet.")
		return
	}

	segment = Segment{
		IVarNum:    uint(bits.TrailingZeros(i_len)),
		OVarNum:    uint(bits.TrailingZeros(o_len)),
		ChildSegs:  child_segs,
		GateMuls:   muls,
		GateAdds:   adds,
		GateConsts: csts,
	}
	return
}

func (buf *InputBuf) ReadECCCircuit() (circuit *ECCCircuit, err error) {
	version_num := buf.ReadUint()
	if version_num != VERSION_NUM {
		err = fmt.Errorf("Incorrect version of circuit serialization")
		return
	}

	fieldMod := buf.ReadField(LEADING_FIELD_BYTES)
	expectedFieldModulus, err := buf.fieldEnum.FieldModulus()
	if err != nil {
		return
	}
	if fieldMod.Cmp(expectedFieldModulus) != 0 {
		err = fmt.Errorf("Incorrect field mod detected")
		return
	}

	num_public_inputs := buf.ReadUint()
	num_outputs := buf.ReadUint()
	expected_num_output_zeros := buf.ReadUint()

	n_segments := buf.ReadUint()
	var tempSegment Segment
	var segments []Segment
	for i := uint(0); i < n_segments; i++ {
		tempSegment, err = buf.ReadSegment()
		if err != nil {
			return
		}

		segments = append(segments, tempSegment)
	}

	n_layers := buf.ReadUint()
	var layer_ids []uint
	for i := uint(0); i < n_layers; i++ {
		layer_ids = append(layer_ids, buf.ReadUint())
	}

	circuit = &ECCCircuit{
		NumPublicInputs:        num_public_inputs,
		NumOutputs:             num_outputs,
		ExpectedNumOutputZeros: expected_num_output_zeros,

		Segments: segments,
		LayerIds: layer_ids,
	}
	return
}

func (buf *InputBuf) ReadWitness() (witness *Witness, err error) {
	num_witnesses := buf.ReadUint()
	num_private_inputs_per_witness := buf.ReadUint()
	num_public_inputs_per_witness := buf.ReadUint()

	fieldBytes, err := buf.fieldEnum.FieldBytes()
	if err != nil {
		return
	}

	fieldMod := buf.ReadField(LEADING_FIELD_BYTES)
	expectedFieldModulus, err := buf.fieldEnum.FieldModulus()
	if err != nil {
		return
	}

	if fieldMod.Cmp(expectedFieldModulus) != 0 {
		err = fmt.Errorf("Incorrect field mod detected")
		return
	}

	var values []big.Int
	for i := 0; i < int(num_witnesses*(num_private_inputs_per_witness+num_public_inputs_per_witness)); i++ {
		values = append(values, *buf.ReadField(fieldBytes))
	}

	witness = &Witness{
		NumWitnesses:               num_witnesses,
		NumPrivateInputsPerWitness: num_private_inputs_per_witness,
		NumPublicInputsPerWitness:  num_public_inputs_per_witness,
		Values:                     values,
	}
	return
}

func (buf *InputBuf) ReadProof() (proof *Proof, err error) {
	fieldBytes, err := buf.fieldEnum.FieldBytes()
	if err != nil {
		return
	}

	elems := make([]frontend.Variable, 0)
	_ = buf.ReadUint64()
	for buf.Len() > 0 {
		if buf.Len() < fieldBytes {
			err = fmt.Errorf("Trailing bytes, proof parsing fails")
			return
		}
		elems = append(elems, buf.ReadField(fieldBytes))
	}
	proof = &Proof{
		Idx:   0,
		Elems: elems,
	}
	return
}

// CircuitRelation stands for a pair of satisfying circuit-witness together with
// the field that the circuit runs on and the SIMD size (TODO? simd or mpi?)
type CircuitRelation struct {
	pathToCircuit string
	pathToWitness string
	fieldEnum     ECCFieldEnum
	mpiSize       uint
}

func NewCircuitRelation(
	pathToCircuit string,
	pathToWitness string,
	fieldEnum ECCFieldEnum,
	mpiSize uint,
) CircuitRelation {
	return CircuitRelation{
		pathToCircuit: pathToCircuit,
		pathToWitness: pathToWitness,
		fieldEnum:     fieldEnum,
		mpiSize:       mpiSize,
	}
}

// TODO:
// Verifier should not have access to the private part of witness, consider separating the witness
func ReadCircuit(circuitRel CircuitRelation) (expander_circuit *Circuit, private_input [][]frontend.Variable, err error) {
	circuit_input_buf, err := NewInputBuf(circuitRel.pathToCircuit, circuitRel.fieldEnum)
	if err != nil {
		return
	}

	ecc_circuit, err := circuit_input_buf.ReadECCCircuit()
	if err != nil {
		return
	}

	expander_circuit = ecc_circuit.Flatten()

	witness_input_buf, err := NewInputBuf(circuitRel.pathToWitness, circuitRel.fieldEnum)
	if err != nil {
		return
	}
	witness, err := witness_input_buf.ReadWitness()
	if err != nil {
		return
	}

	// Now the witness only takes into account the simd size
	// We're repeating the witness for each mpi
	// TODO: fix this later
	witness.NumWitnesses *= circuitRel.mpiSize
	n_witness_per_mpi_node := len(witness.Values)
	for i := 1; i < int(circuitRel.mpiSize); i++ {
		for j := 0; j < int(n_witness_per_mpi_node); j++ {
			witness.Values = append(witness.Values, witness.Values[j])
		}
	}

	public_input, private_input := witness.ToPubPri()
	expander_circuit.PublicInput = public_input

	return
}

func ReadProof(proof_filename string, fieldEnum ECCFieldEnum) (proof *Proof, err error) {
	proof_input_buf, err := NewInputBuf(proof_filename, fieldEnum)
	if err != nil {
		return
	}
	proof, err = proof_input_buf.ReadProof()
	return
}
