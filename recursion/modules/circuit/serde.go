package circuit

import (
	"encoding/binary"
	"math/big"
	"math/bits"
	"os"

	"github.com/consensys/gnark/frontend"
)

type InputBuf struct {
	data []byte
}

func NewInputBuf(file_name string) *InputBuf {
	data, err := os.ReadFile(file_name)
	if err != nil {
		panic("Unable to open file")
	}
	return &InputBuf{data: data}
}

func (buf *InputBuf) Step(n_bytes uint) {
	buf.data = buf.data[n_bytes:]
}

func (buf *InputBuf) Len() uint {
	return uint(len(buf.data))
}

func (buf *InputBuf) ReadUint64() uint64 {
	x := binary.LittleEndian.Uint64(buf.data[:8])
	buf.Step(8)
	return x
}

func (buf *InputBuf) ReadUint() uint {
	return uint(buf.ReadUint64())
}

func (buf *InputBuf) ReadUint8() uint8 {
	x := buf.data[0]
	buf.Step(1)
	return x
}

const N_FIELD_BYTES uint = 32

func (buf *InputBuf) ReadField(field_size_in_bytes uint) *big.Int {

	// little endian to big endian
	for i := uint(0); i < field_size_in_bytes/2; i++ {
		buf.data[i], buf.data[field_size_in_bytes-i-1] =
			buf.data[field_size_in_bytes-i-1], buf.data[i]
	}

	x := big.NewInt(0).SetBytes(buf.data[:field_size_in_bytes])
	buf.Step(field_size_in_bytes)
	return x
}

func (buf *InputBuf) ReadGate(input_num uint) Gate {
	var i_ids []uint
	for i := uint(0); i < input_num; i++ {
		i_ids = append(i_ids, buf.ReadUint())
	}
	o_id := buf.ReadUint()

	var coef Coef
	coef_type_u8 := buf.ReadUint8()
	switch coef_type_u8 {
	case 1:
		coef.CoefType = Constant
		coef.Value = *buf.ReadField(N_FIELD_BYTES)
		coef.RandomValue = 0 // This will not be used, but gnark will complain if this value is nil
	case 2:
		coef.CoefType = Random
		coef.RandomValue = 1 // Give some default value for random, the actuall value should be generated by transcript
	case 3:
		coef.CoefType = PublicInput
		coef.RandomValue = 0 // This will not be used, but gnark will complain if this value is nil
		coef.InputIdx = buf.ReadUint()
		if input_num != 0 {
			panic("Public input can only appear in the form of cst gate")
		}
	default:
		panic("Unrecognized coef type")
	}

	return Gate{
		IIds: i_ids,
		OId:  o_id,
		Coef: coef,
	}
}

func (buf *InputBuf) ReadAllocation() Allocation {
	return Allocation{
		IOffset: buf.ReadUint(),
		OOffset: buf.ReadUint(),
	}
}

func (buf *InputBuf) ReadChildSegInfo() ChildSegInfo {
	id := buf.ReadUint()

	n_allocations := buf.ReadUint()
	var allocation []Allocation
	for i := uint(0); i < n_allocations; i++ {
		allocation = append(allocation, buf.ReadAllocation())
	}

	return ChildSegInfo{
		Id:         id,
		Allocation: allocation,
	}
}

func (buf *InputBuf) ReadSegment() Segment {
	i_len := buf.ReadUint()
	o_len := buf.ReadUint()

	if bits.OnesCount(i_len) != 1 || bits.OnesCount(o_len) != 1 {
		panic("Incorrect input or output length")
	}

	n_child_seg := buf.ReadUint()
	var child_segs []ChildSegInfo
	for i := uint(0); i < n_child_seg; i++ {
		child_segs = append(child_segs, buf.ReadChildSegInfo())
	}

	n_muls := buf.ReadUint()
	var muls []Gate
	for i := uint(0); i < n_muls; i++ {
		muls = append(muls, buf.ReadGate(2))
	}

	n_adds := buf.ReadUint()
	var adds []Gate
	for i := uint(0); i < n_adds; i++ {
		adds = append(adds, buf.ReadGate(1))
	}

	n_csts := buf.ReadUint()
	var csts []Gate
	for i := uint(0); i < n_csts; i++ {
		csts = append(csts, buf.ReadGate(0))
	}

	n_customs := buf.ReadUint()
	if n_customs != 0 {
		panic("Custom gate not supported yet.")
	}

	return Segment{
		IVarNum:    uint(bits.TrailingZeros(i_len)),
		OVarNum:    uint(bits.TrailingZeros(o_len)),
		ChildSegs:  child_segs,
		GateMuls:   muls,
		GateAdds:   adds,
		GateConsts: csts,
	}
}

const VERSION_NUM uint = 3914834606642317635 // b'CIRCUIT6'

func (buf *InputBuf) ReadECCCircuit() *ECCCircuit {
	version_num := buf.ReadUint()
	if version_num != VERSION_NUM {
		panic("Incorrect version of circuit serialization")
	}

	field_mod := buf.ReadField(N_FIELD_BYTES)
	bn254_fr_mod, _ := big.NewInt(0).SetString("21888242871839275222246405745257275088548364400416034343698204186575808495617", 10)
	if field_mod.Cmp(bn254_fr_mod) != 0 {
		panic("Support bn254 fr only, incorrect field mod detected")
	}

	num_public_inputs := buf.ReadUint()
	num_outputs := buf.ReadUint()
	expected_num_output_zeros := buf.ReadUint()

	n_segments := buf.ReadUint()
	var segments []Segment
	for i := uint(0); i < n_segments; i++ {
		segments = append(segments, buf.ReadSegment())
	}

	n_layers := buf.ReadUint()
	var layer_ids []uint
	for i := uint(0); i < n_layers; i++ {
		layer_ids = append(layer_ids, buf.ReadUint())
	}

	return &ECCCircuit{
		NumPublicInputs:        num_public_inputs,
		NumOutputs:             num_outputs,
		ExpectedNumOutputZeros: expected_num_output_zeros,

		Segments: segments,
		LayerIds: layer_ids,
	}
}

func (buf *InputBuf) ReadWitness() *Witness {
	num_witnesses := buf.ReadUint()
	num_private_inputs_per_witness := buf.ReadUint()
	num_public_inputs_per_witness := buf.ReadUint()
	modulus := buf.ReadField(N_FIELD_BYTES)
	bn254_fr_modulus, _ := big.NewInt(0).SetString("21888242871839275222246405745257275088548364400416034343698204186575808495617", 10)
	if modulus.Cmp(bn254_fr_modulus) != 0 {
		panic("Support bn254 fr only, incorrect field mod detected")
	}

	var values []big.Int
	for i := 0; i < int(num_witnesses*(num_private_inputs_per_witness+num_public_inputs_per_witness)); i++ {
		values = append(values, *buf.ReadField(N_FIELD_BYTES))
	}

	return &Witness{
		NumWitnesses:               num_witnesses,
		NumPrivateInputsPerWitness: num_private_inputs_per_witness,
		NumPublicInputsPerWitness:  num_public_inputs_per_witness,
		Values:                     values,
	}
}

func (buf *InputBuf) ReadProof() *Proof {
	elems := make([]frontend.Variable, 0)
	_ = buf.ReadUint64()
	for buf.Len() > 0 {
		if buf.Len() < N_FIELD_BYTES {
			panic("Trailing bytes, proof parsing fails")
		}
		elems = append(elems, buf.ReadField(N_FIELD_BYTES))
	}
	return &Proof{
		Idx:   0,
		Elems: elems,
	}
}

// TODO:
// Verifier should not have access to the private part of witness, consider separating the witness
func ReadCircuit(circuit_filename string, witness_filename string, mpi_size uint) (*Circuit, [][]frontend.Variable) {
	circuit_input_buf := NewInputBuf(circuit_filename)
	ecc_circuit := circuit_input_buf.ReadECCCircuit()
	layered_circuit := ecc_circuit.Flatten()

	witness_input_buf := NewInputBuf(witness_filename)
	witness := witness_input_buf.ReadWitness()

	// Now the witness only takes into account the simd size
	// We're repeating the witness for each mpi
	// TODO: fix this later
	witness.NumWitnesses *= mpi_size
	n_witness_per_mpi_node := len(witness.Values)
	for i := 1; i < int(mpi_size); i++ {
		for j := 0; j < int(n_witness_per_mpi_node); j++ {
			witness.Values = append(witness.Values, witness.Values[j])
		}
	}

	public_input, private_input := witness.ToPubPri()
	layered_circuit.PublicInput = public_input

	return layered_circuit, private_input
}

func ReadProof(proof_filename string) *Proof {
	proof_input_buf := NewInputBuf(proof_filename)
	return proof_input_buf.ReadProof()
}
